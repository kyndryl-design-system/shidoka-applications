{"version":3,"file":"components-reusable-tabs-tabs-stories.e643c69f.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAAA;ACwDA;;AAEA;;AAEA;;AAEA;;;;;;;AAQA;;AC3BA;AACA;AACA;AACA;;;;;;;;;;AAaA;;AAKA;AACA;AACA;AACA;;;AAGA;;;;AAIA;;;;AAIA;;;;;;;;AAWA;;AAKA;AACA;AACA;;;;;;;;;;;AAWA;AACA;;;;;;;;;;;;;;;;AAmBA;;AAKA;AACA;AACA;AACA;;;;;;;;;;AAaA","sources":["webpack://@kyndryl-design-system/shidoka-applications/./node_modules/@kyndryl-design-system/shidoka-foundation/components/icon/icon.js","webpack://@kyndryl-design-system/shidoka-applications/./src/components/reusable/tabs/tabs.ts","webpack://@kyndryl-design-system/shidoka-applications/"],"sourcesContent":["import{__decorate as e}from\"../../_virtual/_tslib.js\";import'./../../external/@lit/reactive-element/reactive-element.js';import{html as t}from'./../../external/lit-html/lit-html.js';import{LitElement as i}from'./../../external/lit-element/lit-element.js';import{customElement as o}from'./../../external/@lit/reactive-element/decorators/custom-element.js';import{property as r}from'./../../external/@lit/reactive-element/decorators/property.js';import'./../../external/@lit/reactive-element/decorators/query-assigned-elements.js';import{unsafeHTML as s}from'./../../external/lit-html/directives/unsafe-html.js';import{toString as l,getAttributes as m}from'./../../external/@carbon/icon-helpers/es/index.js';import n from\"./icon.scss.js\";let d=class extends i{constructor(){super(...arguments),this.icon={},this.fill=\"currentColor\"}render(){if(Object.keys(this.icon).length>0){const e=JSON.parse(JSON.stringify(this.icon.attrs));e.fill=this.fill,this.sizeOverride&&(e.width=this.sizeOverride,e.height=this.sizeOverride);const i=l({...this.icon,attrs:m(e)});return t` ${s(i)} `}return null}};d.styles=n,e([r({type:Object})],d.prototype,\"icon\",void 0),e([r({type:String})],d.prototype,\"fill\",void 0),e([r({type:Number})],d.prototype,\"sizeOverride\",void 0),d=e([o(\"kd-icon\")],d);export{d as Icon};\n//# sourceMappingURL=icon.js.map\n","import { LitElement, html } from 'lit';\nimport {\n  customElement,\n  property,\n  queryAssignedElements,\n} from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport TabsScss from './tabs.scss';\n\n/**\n * Tabs.\n * @slot unnamed - Slot for kyn-tab-panel components.\n * @slot tabs - Slot for kyn-tab components.\n * @fires on-change - Emits the new selected Tab ID when switching tabs.\n */\n@customElement('kyn-tabs')\nexport class Tabs extends LitElement {\n  static override styles = TabsScss;\n\n  /** Tab style. `'contained'` or `'line'`. */\n  @property({ type: String })\n  tabStyle = 'contained';\n\n  /** Size of the tab buttons, `'sm'` or `'md'`. Icon size: 16px. */\n  @property({ type: String })\n  tabSize = 'md';\n\n  /** Vertical orientation. */\n  @property({ type: Boolean })\n  vertical = false;\n\n  /** Queries for slotted tabs.\n   * @internal\n   */\n  @queryAssignedElements({ slot: 'tabs', selector: 'kyn-tab' })\n  _tabs!: any;\n\n  /** Queries for slotted tab panels.\n   * @internal\n   */\n  @queryAssignedElements({ selector: 'kyn-tab-panel' })\n  _tabPanels!: any;\n\n  override render() {\n    const wrapperClasses = {\n      wrapper: true,\n      vertical: this.vertical,\n    };\n\n    const tabsClasses = {\n      tabs: true,\n      contained: this.tabStyle === 'contained',\n      line: this.tabStyle === 'line',\n    };\n\n    return html`\n      <div class=${classMap(wrapperClasses)}>\n        <div\n          class=${classMap(tabsClasses)}\n          role=\"tablist\"\n          @keydown=${(e: any) => this._handleKeyboard(e)}\n        >\n          <slot name=\"tabs\" @slotchange=${this._handleSlotChangeTabs}></slot>\n        </div>\n\n        <div class=\"panels\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    this.addEventListener('tab-activated', (e) => this._handleChange(e));\n  }\n\n  override disconnectedCallback() {\n    this.removeEventListener('tab-activated', (e) => this._handleChange(e));\n    super.disconnectedCallback();\n  }\n\n  override willUpdate(changedProps: any) {\n    if (\n      changedProps.has('tabSize') ||\n      changedProps.has('vertical') ||\n      changedProps.has('tabStyle')\n    ) {\n      this._updateChildren();\n    }\n  }\n\n  private _handleSlotChangeTabs() {\n    this._updateChildren();\n  }\n\n  private _updateChildren() {\n    this._tabs.forEach((tab: any) => {\n      tab._size = this.tabSize;\n      tab._vertical = this.vertical;\n      tab._tabStyle = this.tabStyle;\n    });\n\n    this._tabPanels.forEach((tabPanel: any) => {\n      tabPanel._vertical = this.vertical;\n    });\n  }\n\n  /**\n   * Updates children and emits a change event based on the provided\n   * event details when a child kyn-tab is clicked.\n   * @param {any} e - The parameter \"e\" is an event object that contains information about the event\n   * that triggered the handleChange function.\n   */\n  private _handleChange(e: any) {\n    e.stopPropagation();\n    this._updateChildrenSelection(e.detail.tabId);\n    this._emitChangeEvent(e.detail.origEvent, e.detail.tabId);\n  }\n\n  /**\n   * Updates the selected property of tabs and the visible property of tab panels based on\n   * the selected tab ID.\n   * @param {string} selectedTabId - The selectedTabId parameter is a string that represents the ID of\n   * the tab that is currently selected.\n   */\n  private _updateChildrenSelection(selectedTabId: string) {\n    // update tabs selected prop\n    this._tabs.forEach((tab: any) => {\n      tab.selected = tab.id === selectedTabId;\n    });\n\n    // update tab-panels visible prop\n    this._tabPanels.forEach((tabPanel: any) => {\n      tabPanel.visible = tabPanel.tabId === selectedTabId;\n    });\n  }\n\n  /**\n   * Creates and dispatches a custom event called 'on-change' with the provided original event and\n   * selected tab ID as details.\n   * @param {any} origEvent - The origEvent parameter is the original event object that triggered the\n   * change event. It could be any type of event object, such as a click event or a keydown event.\n   * @param {string} selectedTabId - The selectedTabId parameter is a string that represents the ID of\n   * the selected tab.\n   */\n  private _emitChangeEvent(origEvent: any, selectedTabId: string) {\n    const event = new CustomEvent('on-change', {\n      detail: { origEvent: origEvent, selectedTabId: selectedTabId },\n    });\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Handles keyboard events for navigating between tabs.\n   * @param {any} e - The parameter `e` is an event object that represents the keyboard event. It\n   * contains information about the keyboard event, such as the key code of the pressed key.\n   * @returns In this code, the function `_handleKeyboard` returns nothing in all cases\n   * except when the `keyCode` matches the left or right arrow key codes.\n   */\n  private _handleKeyboard(e: any) {\n    const LEFT_ARROW_KEY_CODE = 37;\n    const UP_ARROW_KEY_CODE = 38;\n    const RIGHT_ARROW_KEY_CODE = 39;\n    const DOWN_ARROW_KEY_CODE = 40;\n    const TabCount = this._tabs.length;\n    const SelectedTabIndex = this._tabs.findIndex((tab: any) => tab.selected);\n\n    switch (e.keyCode) {\n      case LEFT_ARROW_KEY_CODE:\n      case UP_ARROW_KEY_CODE: {\n        // activate previous tab\n        let prevIndex =\n          SelectedTabIndex === 0 ? TabCount - 1 : SelectedTabIndex - 1;\n        let prevTab = this._tabs[prevIndex];\n\n        if (prevTab.disabled) {\n          prevIndex = prevIndex === 0 ? TabCount - 1 : prevIndex - 1;\n          prevTab = this._tabs[prevIndex];\n        }\n\n        prevTab.focus();\n\n        this._updateChildrenSelection(prevTab.id);\n        this._emitChangeEvent(e, prevTab.id);\n\n        return;\n      }\n      case RIGHT_ARROW_KEY_CODE:\n      case DOWN_ARROW_KEY_CODE: {\n        // activate next tab\n        let nextIndex =\n          SelectedTabIndex === TabCount - 1 ? 0 : SelectedTabIndex + 1;\n        let nextTab = this._tabs[nextIndex];\n\n        if (nextTab.disabled) {\n          nextIndex = nextIndex === TabCount - 1 ? 0 : nextIndex + 1;\n          nextTab = this._tabs[nextIndex];\n        }\n\n        nextTab.focus();\n\n        this._updateChildrenSelection(nextTab.id);\n        this._emitChangeEvent(e, nextTab.id);\n\n        return;\n      }\n      default: {\n        return;\n      }\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'kyn-tabs': Tabs;\n  }\n}\n"],"names":[],"sourceRoot":""}