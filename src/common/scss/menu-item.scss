@use '../scss/global.scss';
@use '@kyndryl-design-system/shidoka-foundation/scss/mixins/elevation.scss';
@use '@kyndryl-design-system/shidoka-foundation/scss/mixins/typography.scss';
@use '../../common/scss/gradients.scss' as gradient;

// ==== base host ====
:host,
:host(:focus),
:host(:focus-visible) {
  outline: none;
}

// ==== mixins ====
@mixin state-colors($bg, $text, $icon: null) {
  background-color: $bg;

  .menu-item-inner-el {
    color: $text;
  }

  @if $icon != null {
    slot[name='icon']::slotted(span) {
      color: $icon;
    }
  }
}

@mixin disabled-common($bg-default) {
  color: var(--kd-color-text-level-disabled);

  .menu-item-inner-el {
    color: var(--kd-color-text-level-disabled);
  }

  &,
  & * {
    cursor: not-allowed;
  }

  &:hover {
    background-color: $bg-default;
  }
}

@mixin destructive-common {
  color: var(--kd-color-text-variant-destructive);
  border-top: 1px solid var(--kd-color-border-level-tertiary);

  .menu-item-inner-el {
    color: var(--kd-color-text-variant-destructive);
  }

  &:hover {
    background-color: var(--kd-color-status-error-light);
  }

  &:focus-visible {
    border: 2px solid var(--kd-color-border-button-primary-destructive-default);
    outline: none;
    background-color: var(--kd-color-status-error-light);

    .menu-item-inner-el {
      color: var(--kd-color-text-level-primary);
    }
  }
}

@mixin border-gradient-ai(
  $gradient,
  $radius: 4px,
  $width: 1px,
  $surface: transparent
) {
  box-sizing: border-box;
  border: $width solid transparent;
  border-radius: $radius;
  background: linear-gradient(#{$surface}, #{$surface}) padding-box,
    #{$gradient} border-box;
  background-clip: padding-box, border-box;
}

// Centralized pressed mixin to avoid drift between variants.
// $layered=true uses `background` (not `background-color`) to overwrite any gradient layers.
// $important=true adds `!important` to the background to beat prior hover/outline-gradient compositions.
@mixin pressed($bg, $text, $icon, $layered: true, $important: true) {
  @if $layered {
    @if $important {
      background: $bg !important;
    } @else {
      background: $bg;
    }
  } @else {
    @if $important {
      background-color: $bg !important;
    } @else {
      background-color: $bg;
    }
  }

  outline: none;
  border: 1px solid transparent;

  .menu-item-inner-el {
    color: $text;
  }

  slot[name='icon']::slotted(span),
  .check-icon {
    color: $icon;
  }
}

// ==== defaults ====
:host .menu-item {
  background-color: var(--kd-color-background-menu-state-default);
  transition: background-color 150ms ease-out;

  .menu-item-inner-el {
    color: var(--kd-color-text-level-primary);
    transition: color 150ms ease-out;

    &.check-icon {
      color: var(--kd-color-icon-primary);
    }
  }

  // --- state precedence ---

  // 3) focus/open (general; disabled/readonly/destructive overrides below)
  &:focus,
  &:focus-within,
  &:focus-visible {
    outline: none;
    border: 2px solid var(--kd-color-border-variants-focus);
    background-color: var(--kd-color-background-menu-state-focused);
  }

  // 1) disabled
  &[disabled] {
    @include disabled-common(var(--kd-color-background-menu-state-default));
    outline: none;
    border: none;
  }
  // ensure disabled wins over general focus styles
  &[disabled]:focus,
  &[disabled]:focus-within,
  &[disabled]:focus-visible {
    outline: none;
    border: none;
  }

  // 2) readonly (non-disabled)
  &[readonly] {
    cursor: default;
    border: none;
    background-color: var(--kd-color-background-menu-state-default);
    outline: none;
  }
  &[readonly]:hover,
  &[readonly]:active,
  &[readonly]:focus,
  &[readonly]:focus-visible {
    background-color: var(--kd-color-background-menu-state-default);
    border: none;
    outline: none;

    .menu-item-inner-el {
      color: var(--kd-color-text-level-primary);
    }
    & .check-icon {
      color: var(--kd-color-icon-primary);
    }
    slot[name='icon']::slotted(span) {
      color: var(--kd-color-icon-primary);
    }
  }

  // selected + readonly
  &[readonly][selected] {
    background-color: var(--kd-color-background-forms-default);
  }
  &[readonly][selected]:hover,
  &[readonly][selected]:active {
    background-color: var(--kd-color-background-forms-default);
  }

  // highlighted/active guard
  &[readonly]:active,
  &[readonly][highlighted] {
    background: var(--kd-color-background-forms-default) !important;
  }

  // 4) hover (non-AI)
  &:hover {
    @include state-colors(
      var(--kd-color-background-menu-state-hover),
      var(--kd-color-text-level-light),
      var(--kd-color-icon-light)
    );
  }
  // cancel hover when readonly/disabled/ai-connected/destructive
  // &[disabled]:hover,
  // &[readonly]:hover,
  // &.ai-connected:hover,
  // &.destructive:hover {

  // }

  // 5) selected (non-disabled)
  &[selected] {
    @include state-colors(
      var(--kd-color-background-menu-state-open),
      var(--kd-color-text-level-primary)
    );
  }
  &[selected]:hover {
    @include state-colors(
      var(--kd-color-background-menu-state-hover),
      var(--kd-color-text-level-light)
    );
  }

  // leave commented out for now as it causes issues with keyboard nav
  // 6) highlighted (non-disabled)
  // &[highlighted] {
  //   @include state-colors(
  //     var(--kd-color-background-menu-state-hover),
  //     var(--kd-color-text-level-light)
  //   );
  //   // default (non-AI) focus ring
  //   outline: 1px solid var(--kd-color-border-variants-focus);
  // }

  // ----- AI variant -----
  &.ai-connected {
    background-color: var(--kd-color-background-menu-state-ai-default);
    color: var(--kd-color-text-level-primary);
  }

  &.ai-connected:focus,
  &.ai-connected:focus-within,
  &.ai-connected:focus-visible {
    outline: none;
    border: none;
  }

  &.ai-connected:hover {
    background-color: var(--kd-color-background-menu-state-ai-hover);

    .menu-item-inner-el {
      color: var(--kd-color-text-level-primary);
    }
    slot[name='icon']::slotted(span),
    .check-icon {
      color: var(--kd-color-icon-primary);
    }
  }

  &.ai-connected[highlighted] {
    outline: none;
    background-color: var(--kd-color-background-menu-state-ai-focused);
  }

  &.ai-connected[selected]:hover,
  &.ai-connected[highlighted]:hover {
    @include state-colors(
      var(--kd-color-background-menu-state-ai-hover),
      var(--kd-color-text-level-primary)
    );
    slot[name='icon']::slotted(span),
    .check-icon {
      color: var(--kd-color-icon-primary);
    }
  }

  &.ai-connected:active,
  &.ai-connected[data-pressed],
  &.ai-connected:hover:active,
  &.ai-connected:hover[data-pressed] {
    @include pressed(
      var(--kd-color-background-menu-state-ai-pressed),
      var(--kd-color-text-level-primary),
      var(--kd-color-icon-primary),
      $layered: true,
      $important: true
    );
  }

  &.ai-connected[disabled] {
    @include disabled-common(var(--kd-color-background-menu-state-ai-default));
  }

  // Destructive variant
  &.destructive {
    @include destructive-common;
  }
}

// ---- pressed states (non-AI) ----
:host .menu-item:active,
:host .menu-item[data-pressed],
:host .menu-item[selected]:active,
:host .menu-item[selected][data-pressed],
:host .menu-item[highlighted]:active,
:host .menu-item[highlighted][data-pressed] {
  @include pressed(
    var(--kd-color-background-menu-state-pressed),
    var(--kd-color-text-level-light),
    var(--kd-color-icon-light),
    $layered: true,
    $important: true
  );
}

/* cancel pressed visuals for disallowed cases */
// :host .menu-item.ai-connected:active,
// :host .menu-item.ai-connected[data-pressed],
// :host .menu-item[disabled]:active,
// :host .menu-item[disabled][data-pressed],
// :host .menu-item[readonly]:active,
// :host .menu-item[readonly][data-pressed] {
// }

/* Normalize outline removal when focused */
:host .menu-item:focus,
:host .menu-item:focus-within,
:host .menu-item:focus-visible {
  outline: none;
}
