@use './global.scss';
@use '@kyndryl-design-system/shidoka-foundation/scss/mixins/elevation.scss';
@use '@kyndryl-design-system/shidoka-foundation/scss/mixins/typography.scss';
@use '../../common/scss/gradients.scss' as gradient;

// ==== base host ====
:host,
:host(:focus),
:host(:focus-visible) {
  outline: none;
}

// ==== mixins ====
@mixin state-colors($bg, $text, $icon: null) {
  background-color: $bg;

  .menu-item-inner-el {
    color: $text;
  }

  @if $icon != null {
    slot[name='icon']::slotted(span) {
      color: $icon;
    }
  }
}

@mixin disabled-common($bg-default) {
  color: var(--kd-color-text-level-disabled);

  .menu-item-inner-el {
    color: var(--kd-color-text-level-disabled);
  }

  &,
  & * {
    cursor: not-allowed;
  }

  &:hover {
    background-color: $bg-default;
  }
}

@mixin destructive-common {
  color: var(--kd-color-text-variant-destructive);
  border-top: 1px solid var(--kd-color-border-level-tertiary);

  .menu-item-inner-el {
    color: var(--kd-color-text-variant-destructive);
  }

  &:hover:not([disabled]) {
    background-color: var(--kd-color-status-error-light);
  }
}

@mixin border-gradient-ai(
  $gradient,
  $radius: 4px,
  $width: 1px,
  $surface: transparent
) {
  box-sizing: border-box;
  border: $width solid transparent;
  border-radius: $radius;
  background: linear-gradient(#{$surface}, #{$surface}) padding-box,
    #{$gradient} border-box;
  background-clip: padding-box, border-box;
}

// Centralized pressed mixin to avoid drift between variants.
// $layered=true uses `background` (not `background-color`) to overwrite any gradient layers.
// $important=true adds `!important` to the background to beat prior hover/outline-gradient compositions.
@mixin pressed($bg, $text, $icon, $layered: true, $important: true) {
  @if $layered {
    @if $important {
      background: $bg !important;
    } @else {
      background: $bg;
    }
  } @else {
    @if $important {
      background-color: $bg !important;
    } @else {
      background-color: $bg;
    }
  }

  outline: none;
  border: 1px solid transparent;

  .menu-item-inner-el {
    color: $text;
  }

  slot[name='icon']::slotted(span),
  .check-icon {
    color: $icon;
  }
}

// ==== defaults ====
.menu-item {
  background-color: var(--kd-color-background-menu-state-default);
  transition: background-color 150ms ease-out;

  .menu-item-inner-el {
    color: var(--kd-color-text-level-primary);
    transition: color 150ms ease-out;

    &.check-icon {
      color: var(--kd-color-icon-primary);
    }
  }

  // --- state precedence ---

  // 1) disabled
  &[disabled] {
    @include disabled-common(var(--kd-color-background-menu-state-default));
    outline: none;
  }

  // 2) readonly (non-disabled)
  &[readonly]:not([disabled]) {
    cursor: default;
    border: none;
    background-color: var(--kd-color-background-menu-state-default);
    outline: none;

    // keep visual stable on interactions
    &:is(:hover, :active, :focus, :focus-visible) {
      background-color: var(--kd-color-background-menu-state-default);
      border: none;
      outline: none;

      .menu-item-inner-el {
        color: var(--kd-color-text-level-primary);
      }
      & .check-icon {
        color: var(--kd-color-icon-primary);
      }
      slot[name='icon']::slotted(span) {
        color: var(--kd-color-icon-primary);
      }
    }

    // selected + readonly
    &[selected] {
      background-color: var(--kd-color-background-forms-default);

      &:is(:hover, :active) {
        background-color: var(--kd-color-background-forms-default);
      }
    }

    // highlighted/active guard
    &:is(:active, [highlighted]) {
      background: var(--kd-color-background-forms-default) !important;
    }
  }

  // 3) focus/open (non-disabled, non-readonly)
  &:is(:focus, :focus-within, :focus-visible):not([disabled]):not([readonly]) {
    @include state-colors(
      var(--kd-color-background-menu-state-open),
      var(--kd-color-text-level-primary)
    );
    outline: 2px solid var(--kd-color-border-variants-focus);
    outline-offset: -2px;
  }

  // 4) hover (non-disabled, non-readonly, non-AI)
  &:hover:not([disabled]):not([readonly]):not(.ai-connected) {
    @include state-colors(
      var(--kd-color-background-menu-state-hover),
      var(--kd-color-text-level-light),
      var(--kd-color-icon-light)
    );
  }

  // 5) selected (non-disabled)
  &[selected]:not([disabled]) {
    @include state-colors(
      var(--kd-color-background-menu-state-open),
      var(--kd-color-text-level-primary)
    );

    &:hover {
      @include state-colors(
        var(--kd-color-background-menu-state-hover),
        var(--kd-color-text-level-light)
      );
    }
  }

  // 6) highlighted (non-disabled)
  &[highlighted]:not([disabled]) {
    @include state-colors(
      var(--kd-color-background-menu-state-hover),
      var(--kd-color-text-level-light)
    );
    // default (non-AI) focus ring
    outline: 1px solid var(--kd-color-border-variants-focus);
  }

  // ----- AI variant -----
  &.ai-connected {
    background-color: var(--kd-color-background-menu-state-ai-default);
    color: var(--kd-color-text-level-primary);

    // focus/open
    &:is(:focus, :focus-within, :focus-visible):not([disabled]):not(
        [readonly]
      ) {
      @include state-colors(
        var(--kd-color-background-menu-state-ai-open),
        var(--kd-color-text-level-primary)
      );
      outline: 2px solid var(--kd-color-border-variants-focus);
      outline-offset: -2px !important;
    }

    // hover (non-pressed)
    &:hover:not([disabled]):not([readonly]):not(.option-is-readonly):not(
        [data-pressed]
      ):not(:active) {
      background-color: var(--kd-color-background-menu-state-ai-hover);

      .menu-item-inner-el {
        color: var(--kd-color-text-level-primary);
      }
      slot[name='icon']::slotted(span),
      .check-icon {
        color: var(--kd-color-icon-primary);
      }
    }

    // highlighted
    &[highlighted]:not([disabled]):not([readonly]):not(:active):not(
        [data-pressed]
      ) {
      outline: none;
      @include border-gradient-ai(
        $gradient: gradient.$ai-gradient-default,
        $radius: 0,
        $width: 1px,
        $surface: var(--kd-color-background-menu-state-ai-focused)
      );
    }

    // selected/highlighted + hover â€” keep text primary
    &:is([selected], [highlighted]):hover:not([disabled]):not([readonly]) {
      @include state-colors(
        var(--kd-color-background-menu-state-ai-hover),
        var(--kd-color-text-level-primary)
      );
      slot[name='icon']::slotted(span),
      .check-icon {
        color: var(--kd-color-icon-primary);
      }
    }

    // PRESSED (AI)
    &:is(:active, [data-pressed]):not([disabled]):not([readonly]),
    &:hover:is(:active, [data-pressed]):not([disabled]):not([readonly]) {
      @include pressed(
        var(--kd-color-background-menu-state-ai-pressed),
        var(--kd-color-text-level-primary),
        var(--kd-color-icon-primary),
        $layered: true,
        $important: true
      );
    }

    // disabled within AI
    &[disabled] {
      @include disabled-common(
        var(--kd-color-background-menu-state-ai-default)
      );
    }
  }

  // Destructive variant
  &.destructive {
    @include destructive-common;
  }
}

// ---- pressed states (non-AI) ----
.menu-item:not(.ai-connected):is(:active, [data-pressed]):not([disabled]):not(
    [readonly]
  ),
.menu-item:not(.ai-connected):hover:is(:active, [data-pressed]):not(
    [disabled]
  ):not([readonly]),
.menu-item:not(.ai-connected)[selected]:is(:active, [data-pressed]):not(
    [disabled]
  ):not([readonly]),
.menu-item:not(.ai-connected)[selected]:hover:is(:active, [data-pressed]):not(
    [disabled]
  ):not([readonly]),
.menu-item:not(.ai-connected)[highlighted]:is(:active, [data-pressed]):not(
    [disabled]
  ):not([readonly]),
.menu-item:not(.ai-connected)[highlighted]:hover:is(
    :active,
    [data-pressed]
  ):not([disabled]):not([readonly]) {
  @include pressed(
    var(--kd-color-background-menu-state-pressed),
    var(--kd-color-text-level-light),
    var(--kd-color-icon-light),
    $layered: true,
    $important: true
  );
}

// Normalize outline removal when focused (component manages its own rings)
.menu-item:is(:focus, :focus-within, :focus-visible) {
  outline: none;
}
